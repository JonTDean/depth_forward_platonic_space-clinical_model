<!--- GENERATED by .codex codex-sync. Do not edit directly. --->

# Workspace Rules for Coding Agents (Codex-ready)

> This file is concatenated from `code/.codex/*.md` in numeric order so Codex can read one page per directory.


# Core Rule

> **Every code change must stay in sync with docs, reference terminology, and kanban.**

If you add/change/remove behavior, you MUST update:
- Relevant **system-design docs**
- **Reference terminology** (if semantics change)
- The corresponding **kanban card(s)**


# Project Map (what lives where)

_All paths relative to `code/`._

## Kanban
- `docs/kanban/**/*.md` (mirrored into `docs/book/src/kanban/**` via `cargo make docs-sync`)

## Reference terminology
- `docs/reference-terminology/semantic-relationships.yaml`  
  Keep semantic relationships (synonym, hypernym, mapping states) consistent with code & docs.

## System-design docs

### Base / workspace layout
- `docs/system-design/base/directory-architecture.md` � **Read this first** to pick crate homes.  
  Buckets: `app/`, `domain/`, `platform/`.

### FHIR system (selected)
- Architecture: `docs/system-design/fhir/architecture/system-architecture.md`
- Behavior: `docs/system-design/fhir/behavior/sequence-servicerequest.md`, `state-servicerequest.md`
- Models: `docs/system-design/fhir/models/class-model.md`, `data-model-er.md`
- Overview: `docs/system-design/fhir/overview.md` / `index.md`

### NCIt mapping system (selected)
- Architecture: `docs/system-design/ncit/architecture/system-architecture.md`, `architecture.md`
- Behavior: `docs/system-design/ncit/behavior/sequence-servicerequest.md`, `state-servicerequest.md`
- Models: `docs/system-design/ncit/models/class-model.md`, `data-model-er.md`
- Overview: `docs/system-design/ncit/index.md`

## Workspace tooling
- `Makefile.toml` + `data/makefiles/` � standardized cargo-make tasks
- `docs/book/` � mdBook sources and built HTML
- `docs/runbook/` � runbooks (synced into the mdBook)
- `data/environment/` � `.env.*.example` templates (loader: `dfps_configuration`)

## Binary entrypoint
- `src/main.rs` � if used; may compose `lib/pipeline` etc.


# General Workflow (Feature / Refactor / Bugfix)

1) **Locate the kanban file**
   - Domain/fake_data/test skeleton ? `docs/kanban/feature-base-skeleton.md`
   - FHIR ingestion MVP ? `docs/kanban/feature-fhir-pipeline-mvp.md`
   - NCIt mapping skeleton ? `docs/kanban/feature-mapping-ncit-skeleton.md`

2) **Read system-design first**
   - FHIR ? `docs/system-design/fhir/**`
   - NCIt ? `docs/system-design/ncit/**`
   - Workspace layout ? `docs/system-design/base/directory-architecture.md`
   - Semantics ? `docs/reference-terminology/semantic-relationships.yaml`

3) **Plan the change**
   - Decide crates/modules to touch
   - Identify which docs & kanban cards must be updated (create a new card if none fits)

4) **Implement**
   - Respect bounded contexts:
     - Domain invariants ? `lib/domain/core`
     - Generators ? `lib/domain/fake_data`
     - FHIR transforms ? `lib/domain/ingestion`
     - Mapping engine ? `lib/domain/mapping`
     - Orchestration ? `lib/domain/pipeline`

5) **Update tests**
   - Unit tests (per crate)
   - Integration & e2e in `lib/platform/test_suite/tests/**`
   - Regression fixtures under `lib/platform/test_suite/fixtures/regression/`

6) **Run standard checks**
   - `cargo make fmt` � `cargo make clippy` � `cargo make test`
   - If docs changed: `cargo make docs` (builds mdBook after `docs-sync`)

7) **Update docs, terminology, kanban**
   - Keep behavior and flows aligned; run `docs-sync` + `docs`
   - Update `semantic-relationships.yaml` if semantics changed
   - Move kanban cards across columns; don�t rewrite checklists�check them off


# Kanban Version Sync (Lightweight, Docs‑Only)

**Scope:** applies when modifying any file under `docs/kanban/**`.  
**Goal:** keep **epic-level** versioning in sync **without** bumping Cargo versions on every checkbox.

---

## When you check off a Kanban item

Every time you change a checklist line from `- [ ]` to `- [x]` in `docs/kanban/**`:

1) **Read the current workspace version** from `code/Cargo.toml` -> `[workspace.package].version`.  
   If missing, write `Unreleased` instead of a version number for the steps below.

2) **Update the epic header** in the Kanban you touched:
   - If the epic is newly started and its “Introduced in” is `_TBD_`, set it to the current workspace version (or `Unreleased` if no version chosen yet).
   - Always set **“Last updated in”** to the current workspace version (or `Unreleased`).

   Example:
   ```markdown
   > Status: **In progress**  
   > Introduced in: `v0.2.0`  
   > Last updated in: `v0.2.1`
   ```

3) **Update the cross‑epic index** at `docs/kanban/_epic_versions.yaml`.  
   Ensure the epic ID is present with `introduced_in` and `last_updated_in`.

   ```yaml
   epics:
     FP-07:
       introduced_in: v0.2.0
       last_updated_in: v0.2.1
     MAP-09:
       introduced_in: v0.2.0
       last_updated_in: v0.2.1
   ```

4) **Add/refresh an Unreleased changelog entry** in `CHANGELOG.md` referencing the epic and the exact checklist line you checked:
   ```markdown
   ## [Unreleased]
   ### Changed
   - FP-07 – “Normalize ServiceRequest.status casing” (checkbox completed)
   ```

5) **Commit message**  
   Use a docs‑scoped commit that cites the epic:
   ```
   docs(FP-07): check off “Normalize status casing”; update epic header, versions index, changelog
   ```

> **No code version bump here.** Actual **SemVer** bumps (patch/minor/major) only happen in release PRs or when the change meets your breaking/feature criteria. See “Release flow” below.

---

## Release flow (when you *do* bump versions)

1) Decide the bump: **patch** for backward‑compatible fixes, **minor** for added functionality, **major** for breaking changes.  
2) Update `[workspace.package].version` at `code/Cargo.toml` and switch all `Unreleased` epic headers/entries that shipped in this release to that version.  
3) Convert `## [Unreleased]` bullets into a final `## [X.Y.Z] – YYYY‑MM‑DD` section.  
4) Tag: `git tag -a vX.Y.Z -m "..."; git push origin vX.Y.Z`.

*(SemVer definitions; Keep‑a‑Changelog section structure.)*


# Kanban Maintenance

## Card ID prefixes
- Base skeleton: `DM-xx`, `WS-xx`, `FD-xx`, `TS-xx`
- FHIR pipeline: `FP-xx`
- NCIt mapping: `MAP-xx`

## Adding a card (example)
```markdown
### FP-07 � Validation & error surface
- [ ] Add `IngestionError` in `lib/domain/ingestion/src/transforms.rs`
- [ ] Update FHIR semantics in `docs/system-design/fhir/behavior/sequence-servicerequest.md`
- [ ] Add regression fixtures under `lib/platform/test_suite/fixtures/regression/`
- [ ] Document error codes in `docs/reference-terminology/semantic-relationships.yaml`
```

## Columns

* **TODO ? DOING**: implementation starts
* **DOING ? REVIEW**: code + tests + initial docs written; pass locally
* **REVIEW ? DONE**: acceptance criteria met, docs fully synced


# System-Design ? Code ? Terminology (Traceability)

**Goal:** bi-directional links across code, docs, and terminology.

## From code to docs
Add `//!` headers on significant modules, linking to the exact docs and terminology entries:
```rust
//! NCIt mapping engine and ranking pipeline.
//! See:
//! - docs/system-design/ncit/architecture/system-architecture.md
//! - docs/system-design/ncit/models/class-model.md
//! - docs/system-design/ncit/behavior/state-servicerequest.md
//! - docs/reference-terminology/semantic-relationships.yaml
```

## From docs to code

When updating system-design docs, list the concrete modules they map to (e.g., ingestion transforms, mapping types, e2e test paths).

## Terminology schema linkage

When mapping states/semantics change:

* Update `docs/reference-terminology/semantic-relationships.yaml` with names, directionality, usage
* Add explicit references from docs and code headers to the updated YAML keys


# Acceptance & Quality Gates

A change is acceptable only if:

1. **Tests** - Unit/integration/e2e/property tests updated; `cargo test --all` passes
2. **Formatting & linting** - `cargo fmt --all` and `cargo clippy --all-targets -- -D warnings`
3. **Docs & terminology** - System-design docs updated; terminology consistent; module `//!` headers present
4. **Kanban** - Cards in correct columns; new work discovered is captured as TODO cards with IDs


# Branching & Commit Conventions

## Branching
- Base: `main`; prefer **one card -> one feature branch**.

**Name**
```
<kind>/<card-id>-kebab-summary
```
Where `<kind>` ∈ {`feature`, `bugfix`, `chore`, `docs`, `spike`} and `<card-id>` is the epic/card ID in Kanban (e.g., `FP-07`, `MAP-03`).

**Branch ↔ Epic binding (required)**
- The **active Git branch must be recorded in the epic Kanban** you are working on.
- In the epic header, add or update:
  - `Branch: <branch-name>`
  - `Branch target version: <semver or Unreleased>`
- If the branch name does **not** contain the `<card-id>`, rename the branch to match the convention or note the exception in the epic.

**Epic header example**
```markdown
> Epic: FP-07 – Ingestion error surface
> Branch: feature/FP-07-ingestion-error-surface
> Branch target version: v0.2.1
> Status: DOING
> Introduced in: _TBD_
> Last updated in: v0.2.1
```

## Workflow

1. **TODO -> DOING**
   - Create the branch from `main` using the naming rule.
   - In the epic Kanban, ensure the header contains:
     - `Branch: <branch-name>`
     - `Branch target version: Unreleased` (or seed with the planned semver)
     - `Status: DOING`

2. **Implement**
   - Code + tests + docs as usual.

3. **DOING -> REVIEW or DONE (leaving DOING)**
   - **Update the branch target version in the epic** (metadata only; do **not** bump Cargo here):
     - **PATCH** - routine/internal change
     - **MINOR** - user‑visible addition
     - **MAJOR** - breaking change
   - Set `Last updated in` to that version.
   - Keep `Introduced in: _TBD_` until a release PR.

4. **Merge -> `main`**
   - Move the card to **DONE**.
   - In the epic header, mark it as **included in the upcoming release** (e.g., add `Release: Upcoming` or an equivalent line).
   - Add/refresh a `## [Unreleased]` item in `CHANGELOG.md` referencing the epic ID and the **Branch target version**.

> **Note:** The workspace SemVer in `Cargo.toml` is only bumped in a **release PR** that collects all “Upcoming” epics. Until then, the epic carries the **Branch target version** as intent.

## Commits

**Format**
```
<type>(<card-id>[:<scope>]): short imperative summary
```
`<type>` ∈ {`feat`, `fix`, `refactor`, `chore`, `docs`, `test`, `ci`}

**Examples**
```
feat(FP-07:ingestion): add IngestionError enum and error mapping
fix(MAP-05:mapping): correct NCIt concept id for PET code 78815
docs(DM-05): document core domain model and invariants
```

**Body tips**
- Bullet points of cross‑cutting changes
- Mention updated docs/fixtures
- `Tests:` line with what ran
- If Kanban metadata changed, note it explicitly, e.g.:
  - `Kanban: record Branch=feature/FP-07-...`
  - `Kanban: set Branch target version -> v0.2.1`
  - `CHANGELOG: add Unreleased entry (FP-07)`

## Pre‑merge checklist
- Epic Kanban has `Branch:` recorded and `Branch target version` set
- Card moved to **DONE**; epic marked **Upcoming** (or equivalent)
- `CHANGELOG.md` updated under `[Unreleased]`
- `cargo make fmt` · `cargo make clippy` · `cargo make test` all passing


# Example Agent Flow

**Request:** �Add a new mapping state �HeuristicMatch� between NeedsReview and AutoMapped.�

Steps
1) Kanban � Add/Update card `MAP-09 � Add HeuristicMatch mapping state`
2) Read � NCIt state/behavior docs + terminology YAML + directory architecture
3) Modify � `lib/domain/core/src/mapping/mod.rs`, `lib/domain/mapping/src/lib.rs`
4) Tests � `lib/platform/test_suite/tests/unit/mapping_properties.rs`, e2e as needed
5) Run � fmt, clippy, test
6) Docs � Update NCIt behavior docs + terminology YAML
7) Kanban � Move `MAP-09` to **REVIEW**/**DONE** with brief note


# Codex Compatibility Notes

- **Discovery & precedence.** Codex concatenates instruction files in order: global (~/.codex) then project root ? subdirs on the path to CWD. Per directory Codex includes at most **one** file, preferring `AGENTS.override.md` then `AGENTS.md`, then fallback names. (Codex docs)
- **Size limits.** The combined project instruction slice is capped (`project_doc_max_bytes`, 32 KiB by default). Split large guidance across nested directories or raise the cap in config. (Codex docs)
- **Fallback names.** Customize with `project_doc_fallback_filenames` in `~/.codex/config.toml` (or your chosen `CODEX_HOME`).
- **Launching with a local profile.** You can point `CODEX_HOME` at `code/.codex` for repo-specific config.
- **Prompting best practices for agents.** Provide clear file/symbol pointers; include verification steps (`fmt`, `clippy`, `test`, mdBook build); split large tasks. (Codex prompting guide)

References:
- Custom instructions & discovery: Codex �Custom instructions with AGENTS.md�.
- Prompting patterns: Codex �Prompting guide�.


## Crate Responsibilities

# Crate: lib/domain/core (dfps_core)

Responsibilities
- Domain/FHIR/staging/mapping/value types
- Strong typing, serde derives, JSON round-trip tests
- `//!` docs linking to FHIR & NCIt design docs + terminology schema

Keep models consistent with:
- FHIR & NCIt system-design docs
- `docs/reference-terminology/semantic-relationships.yaml`


# Crate: lib/domain/fake_data (dfps_fake_data)

Responsibilities
- Deterministic, seeded generators for domain + FHIR data
- Respect invariants from `lib/domain/core` and system-design behavior
- Update NCIt mock data and terminology semantics when introducing new systems


# Crate: lib/domain/ingestion (dfps_ingestion)

Responsibilities
- FHIR ? staging ? domain transforms with clear error semantics
- Enforce `docs/system-design/fhir/requirements/ingestion-requirements.md`
- Predictable error types for malformed FHIR


# Crate: lib/domain/mapping (dfps_mapping)

Responsibilities
- Mapping logic (CPT/HCPCS/SNOMED/NCIt)
- Rankers (lexical + vector) and rule-based re-rankers
- Deterministic behavior against embedded mock data

States & thresholds
- Enforce `AutoMapped`, `NeedsReview`, `NoMatch` (and any new states) per NCIt docs
- Keep golden tests & regression fixtures updated


# Crate: lib/domain/pipeline (dfps_pipeline)

Responsibilities
- Compose ingestion + mapping + downstream steps into end-to-end jobs
- Expose library functions and CLI (`map_bundles`) that match high-level design flows
- Ensure e2e tests cover the pipeline


# Crate: lib/platform/test_suite (dfps_test_suite)

Responsibilities
- Shared fixtures, assertions, regression/property tests
- e2e pipelines (`fhir_ingest_flow.rs`, `mapping_pipeline.rs`, `service_request_flow.rs`)

Rules
- When bugs are fixed, add/update fixtures and regression tests here

